<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluoride Varnish Applicator</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-orbit-controls@1.3.2/dist/aframe-orbit-controls.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="./styles.css">

</head>
<body>
    <a-scene>


        <a-assets>
            <a-asset-item id="teethModel" src="./Dientes.glb"></a-asset-item>
            <img id="baseTexture" src="./base.png">
            <img id="maskTexture" src="./paint-mask.png">
        </a-assets>
        <a-entity gltf-model="#teethModel" paintable-texture position="0 1 0" scale="0.2 0.2 0.2"></a-entity>
        <a-entity camera look-controls="enabled: false" 
            orbit-controls="target: 0 3 0; 
                            minPolarAngle: 75;  
                            maxPolarAngle: 95;
                            maxAzimuthAngle: 85; 
                            minAzimuthAngle: -85; 
                            minDistance: 3; 
                            maxDistance: 4.5; 
                            initialPosition: 0 3 3.5; 
                            rotateSpeed: 0.2; 
                            enablePan: false;
                            enableDamping: true;
                            dampingFactor: 0.025;">
                        </a-entity>

    </a-scene>




    <div style="position:absolute;top:0;right:0;text-align:center; margin-top: 16px;">
        <!-- Paint preview canvas removed for debug.js to handle -->
        <p>
          <button id="toggleModeBtn" style="padding:8px 16px; background:#4CAF50; color:white; border:none; border-radius:4px; cursor:pointer;">
            Enable Painting
          </button>
        </p>
    </div>
    
    <div id="downstrokeWarning" style="display:none;position:fixed;top:40px;left:50%;transform:translateX(-50%);background:rgba(255,0,0,0.9);color:white;padding:18px 32px;font-size:1.3em;border-radius:8px;z-index:1000;box-shadow:0 2px 12px rgba(0,0,0,0.2);font-family:sans-serif;">
      Please use downward brush strokes!
    </div>
    
    <script>
    AFRAME.registerComponent('paintable-texture', {
        init: function () {
            this.brushSize = 15; // Hardcoded
            this.brushColor = '#7f400e'; // Hardcoded
            this.brushPreviewFudge = 20; // Hardcoded
            this.isPainting = false;
            this.mouse = new THREE.Vector2();
            this.raycaster = new THREE.Raycaster();
            this.paintablePixels = 0;
            this.paintedPixels = 0;
            this.forceDownstrokes = true; // Set to true to only allow painting on downstrokes
            this.lastPaintY = null;
            this.downstrokeThreshold = 10; // px
            this.downstrokeDelta = 0;
            this.upstrokeThreshold = 20; // px
            this.upstrokeDelta = 0;
            this.lastInvalidPaintEvent = 0;
            this.invalidPaintCooldown = 5000; // ms (5 seconds)
            
            // UI
            this.brushSizeInput = document.getElementById('brushSize');
            this.brushSizeValue = document.getElementById('brushSizeValue');
            this.brushColorInput = document.getElementById('brushColor');
            // Add coverage display
            this.coverageDisplay = document.createElement('div');
            this.coverageDisplay.style.position = 'absolute';
            this.coverageDisplay.style.top = '20px';
            this.coverageDisplay.style.left = '20px';
            this.coverageDisplay.style.padding = '10px';
            this.coverageDisplay.style.background = 'rgba(0,0,0,0.7)';
            this.coverageDisplay.style.color = 'white';
            this.coverageDisplay.style.borderRadius = '5px';
            document.body.appendChild(this.coverageDisplay);
            if (this.brushSizeInput && this.brushSizeValue) {
                this.brushSizeInput.addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    this.brushSizeValue.textContent = this.brushSize;
                });
                this.brushSizeValue.textContent = this.brushSizeInput.value;
                this.brushSize = parseInt(this.brushSizeInput.value);
            }
            if (this.brushColorInput) {
                this.brushColorInput.addEventListener('input', (e) => {
                    this.brushColor = e.target.value;
                });
                this.brushColor = this.brushColorInput.value;
            }

            // Brush preview fudge factor
            this.brushFudgeInput = document.getElementById('brushFudge');
            this.brushFudgeValue = document.getElementById('brushFudgeValue');
            if (this.brushFudgeInput && this.brushFudgeValue) {
                this.brushFudgeInput.addEventListener('input', (e) => {
                    this.brushPreviewFudge = parseInt(e.target.value);
                    this.brushFudgeValue.textContent = this.brushPreviewFudge;
                });
                this.brushFudgeValue.textContent = this.brushFudgeInput.value;
                this.brushPreviewFudge = parseInt(this.brushFudgeInput.value);
            }

            // Lowered canvas resolution for performance
            this.canvasResolution = 512;
            // Paint layer (user paint only, transparent by default)
            this.paintLayerCanvas = document.createElement('canvas');
            this.paintLayerCanvas.width = this.canvasResolution;
            this.paintLayerCanvas.height = this.canvasResolution;
            this.paintLayerCtx = this.paintLayerCanvas.getContext('2d', { alpha: true, willReadFrequently: true });
            this.paintLayerCtx.clearRect(0, 0, this.canvasResolution, this.canvasResolution);
            this.paintLayerCtx.fillStyle = 'rgba(0,0,0,0)';
            this.paintLayerCtx.fillRect(0, 0, this.canvasResolution, this.canvasResolution);

            // Composite canvas (for rendering: base + paint)
            this.paintCanvas = document.createElement('canvas');
            this.paintCanvas.width = this.canvasResolution;
            this.paintCanvas.height = this.canvasResolution;
            this.paintCtx = this.paintCanvas.getContext('2d', { alpha: true });
            this.paintCtx.clearRect(0, 0, this.canvasResolution, this.canvasResolution);
            this.paintCtx.fillStyle = 'rgba(0,0,0,0)';
            this.paintCtx.fillRect(0, 0, this.canvasResolution, this.canvasResolution);

            // Mask
            this.maskImage = document.getElementById('maskTexture');
            this.maskCanvas = document.createElement('canvas');
            this.maskCanvas.width = this.canvasResolution;
            this.maskCanvas.height = this.canvasResolution;
            this.maskCtx = this.maskCanvas.getContext('2d', { willReadFrequently: true });

            // Texture
            this.texture = new THREE.CanvasTexture(this.paintCanvas);
            
            this.toggleModeBtn = document.getElementById('toggleModeBtn');
            this.orbitCamera = document.querySelector('[camera]');
            this.paintMode = false; // Start in orbit mode

            if (this.toggleModeBtn && this.orbitCamera) {
                this.toggleModeBtn.addEventListener('click', () => {
                    this.paintMode = !this.paintMode;
                    if (this.paintMode) {
                        this.toggleModeBtn.textContent = 'Enable Orbit';
                        this.toggleModeBtn.style.background = '#f44336';
                        this.orbitCamera.setAttribute('orbit-controls', 'enabled', false);
                    } else {
                        this.toggleModeBtn.textContent = 'Enable Painting';
                        this.toggleModeBtn.style.background = '#4CAF50';
                        this.orbitCamera.setAttribute('orbit-controls', 'enabled', true);
                    }
                });
            }

            // Coverage batching (suggestion 1)
            this.coverageNeedsUpdate = false;
            this.coverageUpdateInterval = setInterval(() => {
                if (this.coverageNeedsUpdate) {
                    this.calculateCoverage();
                    this.coverageNeedsUpdate = false;
                }
            }, 500);

            // Wait for model and mask to load
            this.el.addEventListener('model-loaded', () => {
                this.mesh = this.el.getObject3D('mesh');
                if (!this.mesh) return;
                // Set up base texture
                this.baseImage = document.getElementById('baseTexture');
                this.baseImage.onload = () => {
                    this.applyTexture();
                };
                if (this.baseImage.complete && this.baseImage.naturalWidth !== 0) {
                    this.applyTexture();
                }
            });
            this.maskImage.onload = () => {
                this.maskCtx.drawImage(this.maskImage, 0, 0, this.canvasResolution, this.canvasResolution);
                this.maskData = this.maskCtx.getImageData(0, 0, this.canvasResolution, this.canvasResolution);
            };
            if (this.maskImage.complete && this.maskImage.naturalWidth !== 0) {
                this.maskCtx.drawImage(this.maskImage, 0, 0, this.canvasResolution, this.canvasResolution);
                this.maskData = this.maskCtx.getImageData(0, 0, this.canvasResolution, this.canvasResolution);
            }

            // Mouse painting
            const sceneEl = this.el.sceneEl;
            sceneEl.addEventListener('mousedown', (e) => {
                if (!this.paintMode) return;
                this.isPainting = true;
                this.lastPaintY = e.clientY;
                this.downstrokeDelta = 0;
            });
            window.addEventListener('mouseup', () => {
                this.isPainting = false;
                this.lastPaintY = null;
                this.downstrokeDelta = 0;
            });
            sceneEl.addEventListener('mousemove', (e) => {
                if (this.isPainting && this.paintMode) {
                    if (this.forceDownstrokes) {
                        if (this.lastPaintY === null) {
                            this.lastPaintY = e.clientY;
                        }
                        let deltaY = e.clientY - this.lastPaintY;
                        if (deltaY > 0) { // Downstroke
                            this.downstrokeDelta += deltaY;
                            this.upstrokeDelta = 0; // Reset upstroke delta on down movement
                            if (this.downstrokeDelta >= this.downstrokeThreshold) {
                                this.paintFromMouse(e);
                                this.downstrokeDelta = 0; // Reset after painting
                            }
                        } else if (deltaY < 0) { // Upstroke
                            this.upstrokeDelta += Math.abs(deltaY);
                            this.downstrokeDelta = 0; // Reset downstroke delta on up movement
                            if (this.upstrokeDelta >= this.upstrokeThreshold) {
                                const now = Date.now();
                                if (now - this.lastInvalidPaintEvent > this.invalidPaintCooldown) {
                                    const event = new CustomEvent('invalid-paint-direction', { detail: { direction: 'up' } });
                                    window.dispatchEvent(event);
                                    this.lastInvalidPaintEvent = now;
                                }
                                this.upstrokeDelta = 0; // Reset after firing
                            }
                        }
                        this.lastPaintY = e.clientY;
                    } else {
                        this.paintFromMouse(e);
                    }
                }
            });

            // Brush texture for fake normal effect
            this.useTextureBrush = true;
            this.brushTexture = new window.Image();
            this.brushTexture.src = 'brush2.png'; // <-- Place your PNG here
            this.brushPattern = null;
            this.brushTexture.onload = () => {
                this.brushPattern = this.paintLayerCtx.createPattern(this.brushTexture, 'repeat');
            };
        },
        applyTexture: function () {
            // Composite: base + paint layer
            this.paintCtx.clearRect(0, 0, this.canvasResolution, this.canvasResolution);
            this.paintCtx.drawImage(this.baseImage, 0, 0, this.canvasResolution, this.canvasResolution);
            this.paintCtx.drawImage(this.paintLayerCanvas, 0, 0, this.canvasResolution, this.canvasResolution);
            this.texture.needsUpdate = true;
            // Set on all mesh materials
            this.mesh.traverse(obj => {
                if (obj.isMesh && obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => {
                            mat.map = this.texture;
                            mat.needsUpdate = true;
                        });
                    } else {
                        obj.material.map = this.texture;
                        obj.material.needsUpdate = true;
                    }
                }
            });
        }, 
        paintFromMouse: function(e) {
            if (!this.mesh || !this.maskData) return;
            const sceneEl = this.el.sceneEl;
            const canvas = sceneEl.renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            this.raycaster.setFromCamera(this.mouse, sceneEl.camera);
            const intersects = this.raycaster.intersectObject(this.mesh, true);
            if (intersects.length > 0 && intersects[0].uv) {
                const uv = intersects[0].uv;
                const x = Math.floor(uv.x * this.canvasResolution);
                const y = Math.floor((1 - uv.y) * this.canvasResolution);
                // Only paint if mask is white here
                const idx = (y * this.canvasResolution + x) * 4;
                if (this.maskData.data[idx] > 200 && this.maskData.data[idx+1] > 200 && this.maskData.data[idx+2] > 200) {
                    this.paintLayerCtx.save();
                    this.paintLayerCtx.beginPath();
                    this.paintLayerCtx.arc(x, y, this.brushSize / 2, 0, 2 * Math.PI);
                    this.paintLayerCtx.closePath();
                    this.paintLayerCtx.clip();
                    if (this.brushPattern) {
                        // Draw the texture
                        this.paintLayerCtx.globalAlpha = 1.0;
                        this.paintLayerCtx.fillStyle = this.brushPattern;
                        this.paintLayerCtx.fillRect(
                            x - this.brushSize / 2,
                            y - this.brushSize / 2,
                            this.brushSize,
                            this.brushSize
                        );
                        // Overlay the color with some transparency
                        this.paintLayerCtx.globalAlpha = 0.5; // Adjust for more/less color tint
                        this.paintLayerCtx.fillStyle = this.brushColor;
                        this.paintLayerCtx.beginPath();
                        this.paintLayerCtx.arc(x, y, this.brushSize / 2, 0, 2 * Math.PI);
                        this.paintLayerCtx.fill();
                        this.paintLayerCtx.globalAlpha = 1.0; // Reset alpha
                    } else {
                        this.paintLayerCtx.fillStyle = this.brushColor;
                        this.paintLayerCtx.beginPath();
                        this.paintLayerCtx.arc(x, y, this.brushSize / 2, 0, 2 * Math.PI);
                        this.paintLayerCtx.fill();
                    }
                    this.paintLayerCtx.restore();
                    this.applyTexture(); // Only update texture on paint
                    this.coverageNeedsUpdate = true; // Batch coverage update
                }
            }
        },
        calculateCoverage: function() {
            if (!this.maskData) return;
            const paintData = this.paintLayerCtx.getImageData(0, 0, this.canvasResolution, this.canvasResolution);
            let paintableCount = 0;
            let paintedCount = 0;
            for (let i = 0; i < this.maskData.data.length; i += 4) {
                if (this.maskData.data[i] > 200 && this.maskData.data[i + 1] > 200 && this.maskData.data[i + 2] > 200) {
                    paintableCount++;
                    if (paintData.data[i + 3] > 0) {
                        paintedCount++;
                    }
                }
            }
            this.paintablePixels = paintableCount;
            this.paintedPixels = paintedCount;
            const coverage = paintableCount > 0 ? (paintedCount / paintableCount * 100).toFixed(1) : '0.0';
            this.coverageDisplay.textContent = `Coverage: ${coverage}%`;
            if (coverage < 25) {
                this.coverageDisplay.style.background = 'rgba(255,0,0,0.7)';
            } else if (coverage < 50) {
                this.coverageDisplay.style.background = 'rgba(255,165,0,0.7)';
            } else if (coverage < 75) {
                this.coverageDisplay.style.background = 'rgba(255,255,0,0.7)';
            } else {
                this.coverageDisplay.style.background = 'rgba(0,255,0,0.7)';
            }
        }
    });

    // UI handler for invalid-paint-direction event
    (function() {
      let warningTimeout = null;
      const warningDiv = document.getElementById('downstrokeWarning');
      window.addEventListener('invalid-paint-direction', function() {
        if (warningTimeout) {
          clearTimeout(warningTimeout);
        }
        warningDiv.style.display = 'block';
        warningTimeout = setTimeout(() => {
          warningDiv.style.display = 'none';
          warningTimeout = null;
        }, 3000);
      });
    })();

      // Wait for both DOM and A-Frame to be ready
      document.addEventListener('DOMContentLoaded', () => {
            const scene = document.querySelector('a-scene');
            if (scene) {
                scene.addEventListener('loaded', () => { 
                    console.log('scene loaded');
                    if (AFRAME.utils.getUrlParameter('debug') === 'true') {
                        var script = document.createElement('script');
                        script.src = './debug.js';
                        document.head.appendChild(script);
                    }

                });
            }
        });
    </script>
</body>
</html>