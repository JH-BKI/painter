<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluoride Varnish Applicator</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-orbit-controls@1.3.2/dist/aframe-orbit-controls.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
    <!-- A-Frame Scene: Sky is always visible -->
    <a-scene embedded vr-mode-ui="enabled: false">
        <a-assets>
            <a-asset-item id="teethModel" src="./Dientes.glb"></a-asset-item>
            <img id="baseTexture" src="./base.png">
            <img id="maskTexture" src="./paint-mask.png">
            <img id="sceneBg" src="./scene-background.jpg">
        </a-assets>
        <a-sky src="#sceneBg" rotation="0 -90 0"></a-sky>
        <!-- Teeth and camera group, shown only in dryteeth/paintteeth states -->
        <a-entity id="teethGroup" visible="false">
            <a-entity gltf-model="#teethModel" paintable-texture position="0 1 0" scale="0.2 0.2 0.2"></a-entity>
            <a-entity camera look-controls="enabled: false" 
                orbit-controls="target: 0 3 0; 
                                minPolarAngle: 75;  
                                maxPolarAngle: 95;
                                maxAzimuthAngle: 85; 
                                minAzimuthAngle: -85; 
                                minDistance: 2.7; 
                                maxDistance: 3.5; 
                                initialPosition: 0 3 3.5; 
                                rotateSpeed: 0.2; 
                                enablePan: false;
                                enableDamping: true;
                                dampingFactor: 0.025;
                                enableRotate: true;
                                enableZoom: true;">
            </a-entity>
        </a-entity>
    </a-scene>

    <!-- Overlay UI: App State Screens -->
    <div id="startScreen" class="aframe-overlay">
        <figure class="image is-16by9">
            <img src="splash.jpg" />
          </figure>
        <h3 class="is-size-3">Fluoride Varnish Application</h3>
        <div class="block">
            <p>In this immersive sikulation, you will learn about fluoride varnish application.</p>
        </div>
        <button class="button is-link" id="toInstructions">Start</button>
    </div>
    <div id="instructionsScreen" class="aframe-overlay">
        <h3 class="is-size-3">Instructions</h3>
        <div class="block">
        <p>Follow the steps to learn about fluoride varnish application.</p>
        <ul>
            <li>Rotate: Drag to orbit</li>
            <li>Zoom: Pinch or scroll</li>
            <li>Paint: Tap/click and drag on teeth</li>
        </ul>
        </div>
        <button class="button is-link" id="toDryTeeth">Next: Controls</button>
    </div>

    <div id="dryTeethOverlay" class="aframe-overlay">  
        <h3 class="is-size-3">Dry the mouth and teeth</h3>
        <div class="block">
        <p>Drying the mouth and teeth using the gauze. NOT FINISHED YET</p>
        </div>
    </div>

    <div id="paintTeethOverlay" class="aframe-overlay" >
        <h3 class="is-size-3">Apply FluorideVarnish</h3>
        <div class="block">
        <p>Apply the fluoride varnish using the brush. NOT FINISHED YET</p>
        </div>
    </div>

    <div id="endScreen" class="aframe-overlay">
        <h3 class="is-size-3">Summary</h3>
        <div class="block">
        <p>Dry Teeth Coverage: <span id="dryteethResult">0</span>%</p>
        <p>Paint Teeth Coverage: <span id="paintteethResult">0</span>%</p>
        </div>
        <div class="block">
        <p>Start the simulation again by selecting the restart button below.</p>
        </div>
        <button class="button is-link" id="restartApp">Restart</button>
    </div>

    <!-- Overlay UI: Only for dryteeth/paintteeth states -->
    <div id="aframeContainer">
        <div class="aframe-topright">
            <button id="lockViewBtn">Lock View</button>
            <div id="zoomDisplay">
                Zoom: <span id="zoomValue">0%</span>
            </div>
        </div>
        <div id="downstrokeWarning">
            Please use downward brush strokes!
        </div>
        <button id="nextStateBtn" class="button is-link">Next</button>
        <button id="clearBtn" class="button is-warning">Clear Fluoride</button>
    </div>
    <!-- Brush preview overlay -->
    <canvas id="brushPreviewOverlay"></canvas>


    <script>
    // App state management
    let appState = 'start';
    let dryteeth = 0;
    let paintteeth = 0;
    let currentCoverage = 0;
    let paintableComponent = null;

    function showState(state) {
        console.log('App state changed to:', state);
        document.getElementById('startScreen').style.display = (state === 'start') ? 'block' : 'none';
        document.getElementById('instructionsScreen').style.display = (state === 'instructions') ? 'block' : 'none';
        document.getElementById('endScreen').style.display = (state === 'end') ? 'block' : 'none';


        document.getElementById('aframeContainer').style.display = (state === 'dryteeth' || state === 'paintteeth') ? 'block' : 'none';
        // Show/hide next button only in aframe states
        const nextBtn = document.getElementById('nextStateBtn');
        nextBtn.style.display = (state === 'dryteeth' || state === 'paintteeth') ? 'block' : 'none';
        // Show/hide coverage display
        if (window.paintableComponent && window.paintableComponent.coverageDisplay) {
            window.paintableComponent.coverageDisplay.style.display = (state === 'dryteeth' || state === 'paintteeth') ? 'block' : 'none';
        }
        // Show/hide teeth model and camera
        const teethGroup = document.querySelector('#teethGroup');
        if (teethGroup) {
            teethGroup.setAttribute('visible', (state === 'dryteeth' || state === 'paintteeth'));
        }
        document.getElementById('dryTeethOverlay').style.display = (state === 'dryteeth') ? 'block' : 'none';
        document.getElementById('paintTeethOverlay').style.display = (state === 'paintteeth') ? 'block' : 'none';
    }

    function resetPainting() {
        if (paintableComponent) {
            // Clear paint layer
            paintableComponent.paintLayerCtx.clearRect(0, 0, paintableComponent.canvasResolution, paintableComponent.canvasResolution);
            paintableComponent.paintLayerCtx.fillStyle = 'rgba(0,0,0,0)';
            paintableComponent.paintLayerCtx.fillRect(0, 0, paintableComponent.canvasResolution, paintableComponent.canvasResolution);
            paintableComponent.applyTexture();
            paintableComponent.coverageNeedsUpdate = true;
            paintableComponent.paintedPixels = 0;
        }
    }

    // State transitions
    document.getElementById('toInstructions').onclick = function() {
        appState = 'instructions';
        showState(appState);
    };
    document.getElementById('toDryTeeth').onclick = function() {
        appState = 'dryteeth';
        showState(appState);
        resetPainting();
    };
    document.getElementById('nextStateBtn').onclick = function() {
        if (appState === 'dryteeth') {
            // Store dryteeth coverage
            if (paintableComponent) {
                dryteeth = paintableComponent.paintablePixels > 0 ? (paintableComponent.paintedPixels / paintableComponent.paintablePixels * 100).toFixed(1) : 0;
            }
            appState = 'paintteeth';
            showState(appState);
            resetPainting();
        } else if (appState === 'paintteeth') {
            // Store paintteeth coverage
            if (paintableComponent) {
                paintteeth = paintableComponent.paintablePixels > 0 ? (paintableComponent.paintedPixels / paintableComponent.paintablePixels * 100).toFixed(1) : 0;
            }
            appState = 'end';
            showState(appState);
            document.getElementById('dryteethResult').textContent = dryteeth;
            document.getElementById('paintteethResult').textContent = paintteeth;
            resetPainting();
        }
    };
    document.getElementById('restartApp').onclick = function() {
        dryteeth = 0;
        paintteeth = 0;
        appState = 'start';
        showState(appState);
        resetPainting();
    };

    // Wait for A-Frame to be ready to get the paintable component
    document.addEventListener('DOMContentLoaded', () => {
        const scene = document.querySelector('a-scene');
        if (scene) {
            scene.addEventListener('loaded', () => {
                paintableComponent = document.querySelector('[paintable-texture]').components['paintable-texture'];
            });
        }
    });
    // Initial state
    showState(appState);

    AFRAME.registerComponent('paintable-texture', {
        init: function () {
            this.brushSize = 15; // Hardcoded
            this.brushColor = '#7f400e'; // Hardcoded
            this.brushPreviewFudge = 20; // Hardcoded
            this.isPainting = false;
            this.mouse = new THREE.Vector2();
            this.raycaster = new THREE.Raycaster();
            this.paintablePixels = 0;
            this.paintedPixels = 0;
            this.forceDownstrokes = true; // Set to true to only allow painting on downstrokes
            this.lastPaintY = null;
            this.downstrokeThreshold = 10; // px
            this.downstrokeDelta = 0;
            this.upstrokeThreshold = 20; // px
            this.upstrokeDelta = 0;
            this.lastInvalidPaintEvent = 0;
            this.invalidPaintCooldown = 5000; // ms (5 seconds)
            
            // UI
            this.brushSizeInput = document.getElementById('brushSize');
            this.brushSizeValue = document.getElementById('brushSizeValue');
            this.brushColorInput = document.getElementById('brushColor');
            // Add coverage display
            this.coverageDisplay = document.createElement('div');
            this.coverageDisplay.style.position = 'absolute';
            this.coverageDisplay.style.top = '20px';
            this.coverageDisplay.style.left = '20px';
            this.coverageDisplay.style.padding = '10px';
            this.coverageDisplay.style.background = 'rgba(0,0,0,0.7)';
            this.coverageDisplay.style.color = 'white';
            this.coverageDisplay.style.borderRadius = '5px';
            document.body.appendChild(this.coverageDisplay);
            if (this.brushSizeInput && this.brushSizeValue) {
                this.brushSizeInput.addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    this.brushSizeValue.textContent = this.brushSize;
                });
                this.brushSizeValue.textContent = this.brushSizeInput.value;
                this.brushSize = parseInt(this.brushSizeInput.value);
            }
            if (this.brushColorInput) {
                this.brushColorInput.addEventListener('input', (e) => {
                    this.brushColor = e.target.value;
                });
                this.brushColor = this.brushColorInput.value;
            }

            // Brush preview fudge factor
            this.brushFudgeInput = document.getElementById('brushFudge');
            this.brushFudgeValue = document.getElementById('brushFudgeValue');
            if (this.brushFudgeInput && this.brushFudgeValue) {
                this.brushFudgeInput.addEventListener('input', (e) => {
                    this.brushPreviewFudge = parseInt(e.target.value);
                    this.brushFudgeValue.textContent = this.brushPreviewFudge;
                });
                this.brushFudgeValue.textContent = this.brushFudgeInput.value;
                this.brushPreviewFudge = parseInt(this.brushFudgeInput.value);
            }

            // Lowered canvas resolution for performance
            this.canvasResolution = 512;
            // Paint layer (user paint only, transparent by default)
            this.paintLayerCanvas = document.createElement('canvas');
            this.paintLayerCanvas.width = this.canvasResolution;
            this.paintLayerCanvas.height = this.canvasResolution;
            this.paintLayerCtx = this.paintLayerCanvas.getContext('2d', { alpha: true, willReadFrequently: true });
            this.paintLayerCtx.clearRect(0, 0, this.canvasResolution, this.canvasResolution);
            this.paintLayerCtx.fillStyle = 'rgba(0,0,0,0)';
            this.paintLayerCtx.fillRect(0, 0, this.canvasResolution, this.canvasResolution);

            // Composite canvas (for rendering: base + paint)
            this.paintCanvas = document.createElement('canvas');
            this.paintCanvas.width = this.canvasResolution;
            this.paintCanvas.height = this.canvasResolution;
            this.paintCtx = this.paintCanvas.getContext('2d', { alpha: true });
            this.paintCtx.clearRect(0, 0, this.canvasResolution, this.canvasResolution);
            this.paintCtx.fillStyle = 'rgba(0,0,0,0)';
            this.paintCtx.fillRect(0, 0, this.canvasResolution, this.canvasResolution);

            // Mask
            this.maskImage = document.getElementById('maskTexture');
            this.maskCanvas = document.createElement('canvas');
            this.maskCanvas.width = this.canvasResolution;
            this.maskCanvas.height = this.canvasResolution;
            this.maskCtx = this.maskCanvas.getContext('2d', { willReadFrequently: true });

            // Texture
            this.texture = new THREE.CanvasTexture(this.paintCanvas);
            
            this.lockViewBtn = document.getElementById('lockViewBtn');
            this.orbitCamera = document.querySelector('[camera]');
            this.isViewLocked = false; // Start with view unlocked

            if (this.lockViewBtn && this.orbitCamera) {
                this.lockViewBtn.addEventListener('click', () => {
                    this.isViewLocked = !this.isViewLocked;
                    if (this.isViewLocked) {
                        this.lockViewBtn.textContent = 'Unlock View';
                        this.lockViewBtn.style.background = '#f44336';
                        this.orbitCamera.setAttribute('orbit-controls', 'enableRotate', false);
                    } else {
                        this.lockViewBtn.textContent = 'Lock View';
                        this.lockViewBtn.style.background = '#4CAF50';
                        this.orbitCamera.setAttribute('orbit-controls', 'enableRotate', true);
                    }
                });
            }

            // Coverage batching (suggestion 1)
            this.coverageNeedsUpdate = false;
            this.coverageUpdateInterval = setInterval(() => {
                if (this.coverageNeedsUpdate) {
                    this.calculateCoverage();
                    this.coverageNeedsUpdate = false;
                }
            }, 500);

            // Wait for model and mask to load
            this.el.addEventListener('model-loaded', () => {
                this.mesh = this.el.getObject3D('mesh');
                if (!this.mesh) return;
                // Set up base texture
                this.baseImage = document.getElementById('baseTexture');
                this.baseImage.onload = () => {
                    this.applyTexture();
                };
                if (this.baseImage.complete && this.baseImage.naturalWidth !== 0) {
                    this.applyTexture();
                }
            });
            this.maskImage.onload = () => {
                this.maskCtx.drawImage(this.maskImage, 0, 0, this.canvasResolution, this.canvasResolution);
                this.maskData = this.maskCtx.getImageData(0, 0, this.canvasResolution, this.canvasResolution);
            };
            if (this.maskImage.complete && this.maskImage.naturalWidth !== 0) {
                this.maskCtx.drawImage(this.maskImage, 0, 0, this.canvasResolution, this.canvasResolution);
                this.maskData = this.maskCtx.getImageData(0, 0, this.canvasResolution, this.canvasResolution);
            }

            // Brush preview overlay
            this.brushPreviewCanvas = document.getElementById('brushPreviewOverlay');
            this.brushPreviewCtx = this.brushPreviewCanvas.getContext('2d');
            // Resize overlay to window
            const resizeBrushPreview = () => {
                this.brushPreviewCanvas.width = window.innerWidth;
                this.brushPreviewCanvas.height = window.innerHeight;
            };
            resizeBrushPreview();
            window.addEventListener('resize', resizeBrushPreview);

            // Show/hide and update brush preview
            this.showBrushPreview = (x, y) => {
                this.brushPreviewCanvas.style.display = 'block';
                this.brushPreviewCtx.clearRect(0, 0, this.brushPreviewCanvas.width, this.brushPreviewCanvas.height);
                this.brushPreviewCtx.beginPath();
                // Use brushSize + brushPreviewFudge for the radius
                const radius = (this.brushSize + this.brushPreviewFudge) / 2;
                this.brushPreviewCtx.arc(x, y, radius, 0, 2 * Math.PI);
                this.brushPreviewCtx.strokeStyle = this.brushColor;
                this.brushPreviewCtx.lineWidth = 2;
                this.brushPreviewCtx.globalAlpha = 0.7;
                this.brushPreviewCtx.stroke();
                this.brushPreviewCtx.globalAlpha = 1.0;
            };
            this.hideBrushPreview = () => {
                this.brushPreviewCanvas.style.display = 'none';
                this.brushPreviewCtx.clearRect(0, 0, this.brushPreviewCanvas.width, this.brushPreviewCanvas.height);
            };

            // Helper to update cursor
            this.updateCursor = (overPaintable) => {
                if (this.isViewLocked) {
                    if (overPaintable || this.isPainting) {
                        document.body.style.cursor = 'crosshair';
                    } else {
                        document.body.style.cursor = 'not-allowed';
                    }
                } else {
                    if (this.isPainting || overPaintable) {
                        document.body.style.cursor = 'crosshair';
                    } else {
                        document.body.style.cursor = 'grab';
                    }
                }
            };

            // Touch painting support
            const sceneEl = this.el.sceneEl;
            sceneEl.addEventListener('touchstart', (e) => {
                e.preventDefault();
                //console.log('touchstart', e);
                const touch = e.touches[0];
                if (!touch) return;
                const canvas = sceneEl.renderer.domElement;
                const rect = canvas.getBoundingClientRect();
                const clientX = touch.clientX;
                const clientY = touch.clientY;
                this.mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, sceneEl.camera);
                const intersects = this.raycaster.intersectObject(this.mesh, true);
                if (intersects.length > 0 && intersects[0].uv) {
                    const uv = intersects[0].uv;
                    const x = Math.floor(uv.x * this.canvasResolution);
                    const y = Math.floor((1 - uv.y) * this.canvasResolution);
                    const idx = (y * this.canvasResolution + x) * 4;
                    if (this.maskData.data[idx] > 200 && this.maskData.data[idx+1] > 200 && this.maskData.data[idx+2] > 200) {
                        this.isPainting = true;
                        this.lastPaintY = clientY;
                        this.downstrokeDelta = 0;
                        this.orbitCamera.setAttribute('orbit-controls', 'enableRotate', false);
                        this.showBrushPreview(clientX, clientY);
                    }
                }
            }, { passive: false });

            sceneEl.addEventListener('touchmove', (e) => {
                e.preventDefault();
                //console.log('touchmove', e);
                const touch = e.touches[0];
                if (!touch) return;
                const canvas = sceneEl.renderer.domElement;
                const rect = canvas.getBoundingClientRect();
                const clientX = touch.clientX;
                const clientY = touch.clientY;
                this.mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, sceneEl.camera);
                const intersects = this.raycaster.intersectObject(this.mesh, true);
                let overPaintable = false;
                if (intersects.length > 0 && intersects[0].uv) {
                    const uv = intersects[0].uv;
                    const x = Math.floor(uv.x * this.canvasResolution);
                    const y = Math.floor((1 - uv.y) * this.canvasResolution);
                    const idx = (y * this.canvasResolution + x) * 4;
                    if (this.maskData.data[idx] > 200 && this.maskData.data[idx+1] > 200 && this.maskData.data[idx+2] > 200) {
                        overPaintable = true;
                    }
                }
                if (this.isPainting) {
                    this.showBrushPreview(clientX, clientY);
                    // Call paintFromMouse with a synthetic event
                    this.paintFromMouse({ clientX, clientY });
                } else if (overPaintable) {
                    this.showBrushPreview(clientX, clientY);
                } else {
                    this.hideBrushPreview();
                }
            }, { passive: false });

            window.addEventListener('touchend', () => {
                if (this.isPainting) {
                    this.isPainting = false;
                    this.lastPaintY = null;
                    this.downstrokeDelta = 0;
                    if (!this.isViewLocked) {
                        this.orbitCamera.setAttribute('orbit-controls', 'enableRotate', true);
                    }
                    // Don't hide preview here; let touchmove handle it
                }
            });
            window.addEventListener('touchcancel', () => {
                this.isPainting = false;
                this.hideBrushPreview();
            });

            sceneEl.addEventListener('mousemove', (e) => {
                // Always check if hovering over a paintable area
                if (!this.mesh) return; // Defensive: mesh may not be loaded yet
                const canvas = sceneEl.renderer.domElement;
                const rect = canvas.getBoundingClientRect();
                this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, sceneEl.camera);
                const intersects = this.raycaster.intersectObject(this.mesh, true);
                let overPaintable = false;
                if (intersects.length > 0 && intersects[0] && intersects[0].uv) {
                    const uv = intersects[0].uv;
                    const x = Math.floor(uv.x * this.canvasResolution);
                    const y = Math.floor((1 - uv.y) * this.canvasResolution);
                    const idx = (y * this.canvasResolution + x) * 4;
                    if (this.maskData.data[idx] > 200 && this.maskData.data[idx+1] > 200 && this.maskData.data[idx+2] > 200) {
                        overPaintable = true;
                    }
                }
                if (this.isPainting) {
                    this.showBrushPreview(e.clientX, e.clientY);
                    this.paintFromMouse(e);
                } else if (overPaintable) {
                    this.showBrushPreview(e.clientX, e.clientY);
                } else {
                    this.hideBrushPreview();
                }
                this.updateCursor(overPaintable);
            });

            sceneEl.addEventListener('mousedown', (e) => {
                // Check if we're clicking on a paintable area (do NOT block painting if view is locked)
                const canvas = sceneEl.renderer.domElement;
                const rect = canvas.getBoundingClientRect();
                this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, sceneEl.camera);
                const intersects = this.raycaster.intersectObject(this.mesh, true);
                if (intersects.length > 0 && intersects[0].uv) {
                    const uv = intersects[0].uv;
                    const x = Math.floor(uv.x * this.canvasResolution);
                    const y = Math.floor((1 - uv.y) * this.canvasResolution);
                    const idx = (y * this.canvasResolution + x) * 4;
                    // If we're on a paintable area, start painting and disable orbit controls
                    if (this.maskData.data[idx] > 200 && this.maskData.data[idx+1] > 200 && this.maskData.data[idx+2] > 200) {
                        this.isPainting = true;
                        this.lastPaintY = e.clientY;
                        this.downstrokeDelta = 0;
                        this.orbitCamera.setAttribute('orbit-controls', 'enableRotate', false);
                        this.showBrushPreview(e.clientX, e.clientY);
                        this.updateCursor(true);
                    }
                }
            });

            window.addEventListener('mouseup', () => {
                if (this.isPainting) {
                    this.isPainting = false;
                    this.lastPaintY = null;
                    this.downstrokeDelta = 0;
                    if (!this.isViewLocked) {
                        this.orbitCamera.setAttribute('orbit-controls', 'enableRotate', true);
                    }
                    // Don't hide preview here; let mousemove handle it
                }
                // On mouseup, update cursor (in case painting stopped)
                this.updateCursor(false);
            });

            // Brush texture for fake normal effect
            this.useTextureBrush = true;
            this.brushTexture = new window.Image();
            this.brushTexture.src = 'brush2.png'; // <-- Place your PNG here
            this.brushPattern = null;
            this.brushTexture.onload = () => {
                this.brushPattern = this.paintLayerCtx.createPattern(this.brushTexture, 'repeat');
            };

            // Add zoom tracking
            this.zoomDisplay = document.getElementById('zoomValue');
            this.initialDistance = 3.5; // Should match initialPosition.z

            // Set default cursor on init
            document.body.style.cursor = 'grab';
        },
        tick: function () {
            // Real-time zoom update
            const camera = document.querySelector('[camera]');
            if (!camera) return;
            const controls = camera.components['orbit-controls'];
            if (!controls || !controls.controls) return;
            const threeControls = controls.controls;
            const currentDistance = threeControls.object.position.distanceTo(threeControls.target);
            // Get min and max distance from orbit-controls attribute
            const orbitAttr = camera.getAttribute('orbit-controls');
            const minDistance = orbitAttr.minDistance || 2.7;
            const maxDistance = orbitAttr.maxDistance || 3.5;
            let zoomPercent = ((maxDistance - currentDistance) / (maxDistance - minDistance)) * 100;
            zoomPercent = Math.max(0, Math.min(100, zoomPercent));
            if (this.zoomDisplay) {
                this.zoomDisplay.textContent = Math.round(zoomPercent) + '%';
            }
        },
        remove: function() {
            // No tick listener to clean up
        },
        applyTexture: function () {
            // Composite: base + paint layer
            this.paintCtx.clearRect(0, 0, this.canvasResolution, this.canvasResolution);
            this.paintCtx.drawImage(this.baseImage, 0, 0, this.canvasResolution, this.canvasResolution);
            this.paintCtx.drawImage(this.paintLayerCanvas, 0, 0, this.canvasResolution, this.canvasResolution);
            this.texture.needsUpdate = true;
            // Set on all mesh materials
            this.mesh.traverse(obj => {
                if (obj.isMesh && obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => {
                            mat.map = this.texture;
                            mat.needsUpdate = true;
                        });
                    } else {
                        obj.material.map = this.texture;
                        obj.material.needsUpdate = true;
                    }
                }
            });
        }, 
        paintFromMouse: function(e) {
            if (!this.mesh || !this.maskData) return;
            const sceneEl = this.el.sceneEl;
            const canvas = sceneEl.renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            this.raycaster.setFromCamera(this.mouse, sceneEl.camera);
            const intersects = this.raycaster.intersectObject(this.mesh, true);
            if (intersects.length > 0 && intersects[0].uv) {
                const uv = intersects[0].uv;
                const x = Math.floor(uv.x * this.canvasResolution);
                const y = Math.floor((1 - uv.y) * this.canvasResolution);
                // Only paint if mask is white here
                const idx = (y * this.canvasResolution + x) * 4;
                if (this.maskData.data[idx] > 200 && this.maskData.data[idx+1] > 200 && this.maskData.data[idx+2] > 200) {
                    this.paintLayerCtx.save();
                    this.paintLayerCtx.beginPath();
                    this.paintLayerCtx.arc(x, y, this.brushSize / 2, 0, 2 * Math.PI);
                    this.paintLayerCtx.closePath();
                    this.paintLayerCtx.clip();
                    if (this.brushPattern) {
                        // Draw the texture
                        this.paintLayerCtx.globalAlpha = 1.0;
                        this.paintLayerCtx.fillStyle = this.brushPattern;
                        this.paintLayerCtx.fillRect(
                            x - this.brushSize / 2,
                            y - this.brushSize / 2,
                            this.brushSize,
                            this.brushSize
                        );
                        // Overlay the color with some transparency
                        this.paintLayerCtx.globalAlpha = 0.5; // Adjust for more/less color tint
                        this.paintLayerCtx.fillStyle = this.brushColor;
                        this.paintLayerCtx.beginPath();
                        this.paintLayerCtx.arc(x, y, this.brushSize / 2, 0, 2 * Math.PI);
                        this.paintLayerCtx.fill();
                        this.paintLayerCtx.globalAlpha = 1.0; // Reset alpha
                    } else {
                        this.paintLayerCtx.fillStyle = this.brushColor;
                        this.paintLayerCtx.beginPath();
                        this.paintLayerCtx.arc(x, y, this.brushSize / 2, 0, 2 * Math.PI);
                        this.paintLayerCtx.fill();
                    }
                    this.paintLayerCtx.restore();
                    this.applyTexture(); // Only update texture on paint
                    this.coverageNeedsUpdate = true; // Batch coverage update
                }
            }
        },
        calculateCoverage: function() {
            if (!this.maskData) return;
            const paintData = this.paintLayerCtx.getImageData(0, 0, this.canvasResolution, this.canvasResolution);
            let paintableCount = 0;
            let paintedCount = 0;
            for (let i = 0; i < this.maskData.data.length; i += 4) {
                if (this.maskData.data[i] > 200 && this.maskData.data[i + 1] > 200 && this.maskData.data[i + 2] > 200) {
                    paintableCount++;
                    if (paintData.data[i + 3] > 0) {
                        paintedCount++;
                    }
                }
            }
            this.paintablePixels = paintableCount;
            this.paintedPixels = paintedCount;
            const coverage = paintableCount > 0 ? (paintedCount / paintableCount * 100).toFixed(1) : '0.0';
            this.coverageDisplay.textContent = `Coverage: ${coverage}%`;
            if (coverage < 25) {
                this.coverageDisplay.style.background = 'rgba(255,0,0,0.7)';
            } else if (coverage < 50) {
                this.coverageDisplay.style.background = 'rgba(255,165,0,0.7)';
            } else if (coverage < 75) {
                this.coverageDisplay.style.background = 'rgba(255,255,0,0.7)';
            } else {
                this.coverageDisplay.style.background = 'rgba(0,255,0,0.7)';
            }
        }
    });

    // UI handler for invalid-paint-direction event
    (function() {
      let warningTimeout = null;
      const warningDiv = document.getElementById('downstrokeWarning');
      window.addEventListener('invalid-paint-direction', function() {
        if (warningTimeout) {
          clearTimeout(warningTimeout);
        }
        warningDiv.style.display = 'block';
        warningTimeout = setTimeout(() => {
          warningDiv.style.display = 'none';
          warningTimeout = null;
        }, 3000);
      });
    })();

      // Wait for both DOM and A-Frame to be ready
      document.addEventListener('DOMContentLoaded', () => {
            const scene = document.querySelector('a-scene');
            if (scene) {
                scene.addEventListener('loaded', () => { 
                    console.log('scene loaded');
                    if (AFRAME.utils.getUrlParameter('debug') === 'true') {
                        var script = document.createElement('script');
                        script.src = './debug.js';
                        document.head.appendChild(script);
                    }

                });
            }
        });

    // Add clear button logic
    document.getElementById('clearBtn').onclick = function() {
        if (paintableComponent) {
            // Clear paint layer
            paintableComponent.paintLayerCtx.clearRect(0, 0, paintableComponent.canvasResolution, paintableComponent.canvasResolution);
            paintableComponent.paintLayerCtx.fillStyle = 'rgba(0,0,0,0)';
            paintableComponent.paintLayerCtx.fillRect(0, 0, paintableComponent.canvasResolution, paintableComponent.canvasResolution);
            paintableComponent.applyTexture();
            paintableComponent.coverageNeedsUpdate = true;
            paintableComponent.paintedPixels = 0;
            paintableComponent.paintablePixels = 0;
            // Recalculate coverage to update UI
            if (typeof paintableComponent.calculateCoverage === 'function') {
                paintableComponent.calculateCoverage();
            }
        }
    };

    // Sway camera component
    AFRAME.registerComponent('sway-camera', {
      schema: {
        amplitude: {type: 'number', default: 5}, // degrees
        speed: {type: 'number', default: 0.5},   // cycles per second
        loops: {type: 'number', default: 1}      // number of cycles, -1 for infinite
      },
      init: function () {
        this.baseRotation = this.el.getAttribute('rotation');
        this.startTime = Date.now();
        this.stopped = false;
        // Lock orbit controls
        if (this.el.components['orbit-controls']) {
          this.el.setAttribute('orbit-controls', 'enableRotate', false);
        }
      },
      tick: function () {
        if (this.stopped) return;
        const t = (Date.now() - this.startTime) / 1000;
        let amplitude = this.data.amplitude;
        let sway = 0;

        if (this.data.loops !== -1) {
          const totalTime = this.data.loops / this.data.speed; // seconds
          const lastLoopStart = totalTime - (1 / this.data.speed);
          if (t >= lastLoopStart) {
            // Ease out in the last loop
            const progress = (t - lastLoopStart) * this.data.speed; // 0 to 1
            const ease = 1 - Math.pow(progress, 2); // quadratic ease-out
            amplitude *= Math.max(0, ease);
          }
          if (t >= totalTime) {
            this.stopped = true;
            this.el.setAttribute('rotation', this.baseRotation);
            if (this.el.components['orbit-controls']) {
              this.el.setAttribute('orbit-controls', 'enableRotate', true);
            }
            this.el.removeAttribute('sway-camera');
            return;
          }
        }

        sway = amplitude * Math.sin(2 * Math.PI * this.data.speed * t);
        this.el.setAttribute('rotation', {
          x: this.baseRotation.x,
          y: this.baseRotation.y + sway,
          z: this.baseRotation.z
        });
      }
    });

    // Global function to toggle camera sway from the console
    window.toggleCameraSway = function(amplitude = 5, speed = 0.2, loops = 1) {
      const cameraEl = document.querySelector('[camera]');
      if (!cameraEl) {
        console.warn('Camera entity not found!');
        return;
      }
      if (cameraEl.hasAttribute('sway-camera')) {
        cameraEl.removeAttribute('sway-camera');
        cameraEl.setAttribute('rotation', {x: 0, y: 0, z: 0});
        console.log('Camera sway disabled.');
      } else {
        cameraEl.setAttribute('sway-camera', `amplitude: ${amplitude}; speed: ${speed}; loops: ${loops}`);
        console.log('Camera sway enabled.');
      }
    };
    </script>
</body>
</html>