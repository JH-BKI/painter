<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluoride Varnish Applicator</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-orbit-controls@1.3.2/dist/aframe-orbit-controls.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.4/css/bulma.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="./styles.css">

</head>
<body>
    <a-scene>


        <a-assets>
            <a-asset-item id="teethModel" src="./Dientes.glb"></a-asset-item>
            <img id="baseTexture" src="./base.png">
            <img id="maskTexture" src="./paint-mask.png">
        </a-assets>
        <a-entity gltf-model="#teethModel" paintable-texture position="0 1 0" scale="0.2 0.2 0.2"></a-entity>
        <a-entity camera look-controls="enabled: false" 
            orbit-controls="target: 0 3 0; 
                            minPolarAngle: 75;  
                            maxPolarAngle: 95;
                            maxAzimuthAngle: 85; 
                            minAzimuthAngle: -85; 
                            minDistance: 2.7; 
                            maxDistance: 3.5; 
                            initialPosition: 0 3 3.5; 
                            rotateSpeed: 0.2; 
                            enablePan: false;
                            enableDamping: true;
                            dampingFactor: 0.025;
                            enableRotate: true;
                            enableZoom: true;">
                        </a-entity>

    </a-scene>




    <div style="position:absolute;top:16px;right:16px;text-align:center;">
        <p>
          <button id="lockViewBtn" style="width:128px;  padding:8px; background:#4CAF50; color:white; border:none; border-radius:4px; cursor:pointer;">
            Lock View
          </button>
        </p>
        <div id="zoomDisplay" style="width:128px; margin-top: 10px; padding: 8px; background: rgba(226, 219, 219, 0.5); color:black; border:2px solid black; border-radius: 4px;">
          Zoom: <span id="zoomValue">0%</span>
        </div>
    </div>
    
    <div id="downstrokeWarning" style="display:none;position:fixed;top:40px;left:50%;transform:translateX(-50%);background:rgba(255,0,0,0.9);color:white;padding:18px 32px;font-size:1.3em;border-radius:8px;z-index:1000;box-shadow:0 2px 12px rgba(0,0,0,0.2);font-family:sans-serif;">
      Please use downward brush strokes!
    </div>
    
    <!-- Brush preview overlay -->
    <canvas id="brushPreviewOverlay" style="position:fixed;top:0;left:0;pointer-events:none;z-index:1001;display:none;"></canvas>

    <script>
    AFRAME.registerComponent('paintable-texture', {
        init: function () {
            this.brushSize = 15; // Hardcoded
            this.brushColor = '#7f400e'; // Hardcoded
            this.brushPreviewFudge = 20; // Hardcoded
            this.isPainting = false;
            this.mouse = new THREE.Vector2();
            this.raycaster = new THREE.Raycaster();
            this.paintablePixels = 0;
            this.paintedPixels = 0;
            this.forceDownstrokes = true; // Set to true to only allow painting on downstrokes
            this.lastPaintY = null;
            this.downstrokeThreshold = 10; // px
            this.downstrokeDelta = 0;
            this.upstrokeThreshold = 20; // px
            this.upstrokeDelta = 0;
            this.lastInvalidPaintEvent = 0;
            this.invalidPaintCooldown = 5000; // ms (5 seconds)
            
            // UI
            this.brushSizeInput = document.getElementById('brushSize');
            this.brushSizeValue = document.getElementById('brushSizeValue');
            this.brushColorInput = document.getElementById('brushColor');
            // Add coverage display
            this.coverageDisplay = document.createElement('div');
            this.coverageDisplay.style.position = 'absolute';
            this.coverageDisplay.style.top = '20px';
            this.coverageDisplay.style.left = '20px';
            this.coverageDisplay.style.padding = '10px';
            this.coverageDisplay.style.background = 'rgba(0,0,0,0.7)';
            this.coverageDisplay.style.color = 'white';
            this.coverageDisplay.style.borderRadius = '5px';
            document.body.appendChild(this.coverageDisplay);
            if (this.brushSizeInput && this.brushSizeValue) {
                this.brushSizeInput.addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    this.brushSizeValue.textContent = this.brushSize;
                });
                this.brushSizeValue.textContent = this.brushSizeInput.value;
                this.brushSize = parseInt(this.brushSizeInput.value);
            }
            if (this.brushColorInput) {
                this.brushColorInput.addEventListener('input', (e) => {
                    this.brushColor = e.target.value;
                });
                this.brushColor = this.brushColorInput.value;
            }

            // Brush preview fudge factor
            this.brushFudgeInput = document.getElementById('brushFudge');
            this.brushFudgeValue = document.getElementById('brushFudgeValue');
            if (this.brushFudgeInput && this.brushFudgeValue) {
                this.brushFudgeInput.addEventListener('input', (e) => {
                    this.brushPreviewFudge = parseInt(e.target.value);
                    this.brushFudgeValue.textContent = this.brushPreviewFudge;
                });
                this.brushFudgeValue.textContent = this.brushFudgeInput.value;
                this.brushPreviewFudge = parseInt(this.brushFudgeInput.value);
            }

            // Lowered canvas resolution for performance
            this.canvasResolution = 512;
            // Paint layer (user paint only, transparent by default)
            this.paintLayerCanvas = document.createElement('canvas');
            this.paintLayerCanvas.width = this.canvasResolution;
            this.paintLayerCanvas.height = this.canvasResolution;
            this.paintLayerCtx = this.paintLayerCanvas.getContext('2d', { alpha: true, willReadFrequently: true });
            this.paintLayerCtx.clearRect(0, 0, this.canvasResolution, this.canvasResolution);
            this.paintLayerCtx.fillStyle = 'rgba(0,0,0,0)';
            this.paintLayerCtx.fillRect(0, 0, this.canvasResolution, this.canvasResolution);

            // Composite canvas (for rendering: base + paint)
            this.paintCanvas = document.createElement('canvas');
            this.paintCanvas.width = this.canvasResolution;
            this.paintCanvas.height = this.canvasResolution;
            this.paintCtx = this.paintCanvas.getContext('2d', { alpha: true });
            this.paintCtx.clearRect(0, 0, this.canvasResolution, this.canvasResolution);
            this.paintCtx.fillStyle = 'rgba(0,0,0,0)';
            this.paintCtx.fillRect(0, 0, this.canvasResolution, this.canvasResolution);

            // Mask
            this.maskImage = document.getElementById('maskTexture');
            this.maskCanvas = document.createElement('canvas');
            this.maskCanvas.width = this.canvasResolution;
            this.maskCanvas.height = this.canvasResolution;
            this.maskCtx = this.maskCanvas.getContext('2d', { willReadFrequently: true });

            // Texture
            this.texture = new THREE.CanvasTexture(this.paintCanvas);
            
            this.lockViewBtn = document.getElementById('lockViewBtn');
            this.orbitCamera = document.querySelector('[camera]');
            this.isViewLocked = false; // Start with view unlocked

            if (this.lockViewBtn && this.orbitCamera) {
                this.lockViewBtn.addEventListener('click', () => {
                    this.isViewLocked = !this.isViewLocked;
                    if (this.isViewLocked) {
                        this.lockViewBtn.textContent = 'Unlock View';
                        this.lockViewBtn.style.background = '#f44336';
                        this.orbitCamera.setAttribute('orbit-controls', 'enableRotate', false);
                    } else {
                        this.lockViewBtn.textContent = 'Lock View';
                        this.lockViewBtn.style.background = '#4CAF50';
                        this.orbitCamera.setAttribute('orbit-controls', 'enableRotate', true);
                    }
                });
            }

            // Coverage batching (suggestion 1)
            this.coverageNeedsUpdate = false;
            this.coverageUpdateInterval = setInterval(() => {
                if (this.coverageNeedsUpdate) {
                    this.calculateCoverage();
                    this.coverageNeedsUpdate = false;
                }
            }, 500);

            // Wait for model and mask to load
            this.el.addEventListener('model-loaded', () => {
                this.mesh = this.el.getObject3D('mesh');
                if (!this.mesh) return;
                // Set up base texture
                this.baseImage = document.getElementById('baseTexture');
                this.baseImage.onload = () => {
                    this.applyTexture();
                };
                if (this.baseImage.complete && this.baseImage.naturalWidth !== 0) {
                    this.applyTexture();
                }
            });
            this.maskImage.onload = () => {
                this.maskCtx.drawImage(this.maskImage, 0, 0, this.canvasResolution, this.canvasResolution);
                this.maskData = this.maskCtx.getImageData(0, 0, this.canvasResolution, this.canvasResolution);
            };
            if (this.maskImage.complete && this.maskImage.naturalWidth !== 0) {
                this.maskCtx.drawImage(this.maskImage, 0, 0, this.canvasResolution, this.canvasResolution);
                this.maskData = this.maskCtx.getImageData(0, 0, this.canvasResolution, this.canvasResolution);
            }

            // Brush preview overlay
            this.brushPreviewCanvas = document.getElementById('brushPreviewOverlay');
            this.brushPreviewCtx = this.brushPreviewCanvas.getContext('2d');
            // Resize overlay to window
            const resizeBrushPreview = () => {
                this.brushPreviewCanvas.width = window.innerWidth;
                this.brushPreviewCanvas.height = window.innerHeight;
            };
            resizeBrushPreview();
            window.addEventListener('resize', resizeBrushPreview);

            // Show/hide and update brush preview
            this.showBrushPreview = (x, y) => {
                this.brushPreviewCanvas.style.display = 'block';
                this.brushPreviewCtx.clearRect(0, 0, this.brushPreviewCanvas.width, this.brushPreviewCanvas.height);
                this.brushPreviewCtx.beginPath();
                // Use brushSize + brushPreviewFudge for the radius
                const radius = (this.brushSize + this.brushPreviewFudge) / 2;
                this.brushPreviewCtx.arc(x, y, radius, 0, 2 * Math.PI);
                this.brushPreviewCtx.strokeStyle = this.brushColor;
                this.brushPreviewCtx.lineWidth = 2;
                this.brushPreviewCtx.globalAlpha = 0.7;
                this.brushPreviewCtx.stroke();
                this.brushPreviewCtx.globalAlpha = 1.0;
            };
            this.hideBrushPreview = () => {
                this.brushPreviewCanvas.style.display = 'none';
                this.brushPreviewCtx.clearRect(0, 0, this.brushPreviewCanvas.width, this.brushPreviewCanvas.height);
            };

            // Helper to update cursor
            this.updateCursor = (overPaintable) => {
                if (this.isViewLocked) {
                    if (overPaintable || this.isPainting) {
                        document.body.style.cursor = 'crosshair';
                    } else {
                        document.body.style.cursor = 'not-allowed';
                    }
                } else {
                    if (this.isPainting || overPaintable) {
                        document.body.style.cursor = 'crosshair';
                    } else {
                        document.body.style.cursor = 'grab';
                    }
                }
            };

            // Touch painting support
            const sceneEl = this.el.sceneEl;
            sceneEl.addEventListener('touchstart', (e) => {
                e.preventDefault();
                //console.log('touchstart', e);
                const touch = e.touches[0];
                if (!touch) return;
                const canvas = sceneEl.renderer.domElement;
                const rect = canvas.getBoundingClientRect();
                const clientX = touch.clientX;
                const clientY = touch.clientY;
                this.mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, sceneEl.camera);
                const intersects = this.raycaster.intersectObject(this.mesh, true);
                if (intersects.length > 0 && intersects[0].uv) {
                    const uv = intersects[0].uv;
                    const x = Math.floor(uv.x * this.canvasResolution);
                    const y = Math.floor((1 - uv.y) * this.canvasResolution);
                    const idx = (y * this.canvasResolution + x) * 4;
                    if (this.maskData.data[idx] > 200 && this.maskData.data[idx+1] > 200 && this.maskData.data[idx+2] > 200) {
                        this.isPainting = true;
                        this.lastPaintY = clientY;
                        this.downstrokeDelta = 0;
                        this.orbitCamera.setAttribute('orbit-controls', 'enableRotate', false);
                        this.showBrushPreview(clientX, clientY);
                    }
                }
            }, { passive: false });

            sceneEl.addEventListener('touchmove', (e) => {
                e.preventDefault();
                //console.log('touchmove', e);
                const touch = e.touches[0];
                if (!touch) return;
                const canvas = sceneEl.renderer.domElement;
                const rect = canvas.getBoundingClientRect();
                const clientX = touch.clientX;
                const clientY = touch.clientY;
                this.mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, sceneEl.camera);
                const intersects = this.raycaster.intersectObject(this.mesh, true);
                let overPaintable = false;
                if (intersects.length > 0 && intersects[0].uv) {
                    const uv = intersects[0].uv;
                    const x = Math.floor(uv.x * this.canvasResolution);
                    const y = Math.floor((1 - uv.y) * this.canvasResolution);
                    const idx = (y * this.canvasResolution + x) * 4;
                    if (this.maskData.data[idx] > 200 && this.maskData.data[idx+1] > 200 && this.maskData.data[idx+2] > 200) {
                        overPaintable = true;
                    }
                }
                if (this.isPainting) {
                    this.showBrushPreview(clientX, clientY);
                    // Call paintFromMouse with a synthetic event
                    this.paintFromMouse({ clientX, clientY });
                } else if (overPaintable) {
                    this.showBrushPreview(clientX, clientY);
                } else {
                    this.hideBrushPreview();
                }
            }, { passive: false });

            window.addEventListener('touchend', () => {
                if (this.isPainting) {
                    this.isPainting = false;
                    this.lastPaintY = null;
                    this.downstrokeDelta = 0;
                    if (!this.isViewLocked) {
                        this.orbitCamera.setAttribute('orbit-controls', 'enableRotate', true);
                    }
                    // Don't hide preview here; let touchmove handle it
                }
            });
            window.addEventListener('touchcancel', () => {
                this.isPainting = false;
                this.hideBrushPreview();
            });

            sceneEl.addEventListener('mousemove', (e) => {
                // Always check if hovering over a paintable area
                if (!this.mesh) return; // Defensive: mesh may not be loaded yet
                const canvas = sceneEl.renderer.domElement;
                const rect = canvas.getBoundingClientRect();
                this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, sceneEl.camera);
                const intersects = this.raycaster.intersectObject(this.mesh, true);
                let overPaintable = false;
                if (intersects.length > 0 && intersects[0] && intersects[0].uv) {
                    const uv = intersects[0].uv;
                    const x = Math.floor(uv.x * this.canvasResolution);
                    const y = Math.floor((1 - uv.y) * this.canvasResolution);
                    const idx = (y * this.canvasResolution + x) * 4;
                    if (this.maskData.data[idx] > 200 && this.maskData.data[idx+1] > 200 && this.maskData.data[idx+2] > 200) {
                        overPaintable = true;
                    }
                }
                if (this.isPainting) {
                    this.showBrushPreview(e.clientX, e.clientY);
                    this.paintFromMouse(e);
                } else if (overPaintable) {
                    this.showBrushPreview(e.clientX, e.clientY);
                } else {
                    this.hideBrushPreview();
                }
                this.updateCursor(overPaintable);
            });

            sceneEl.addEventListener('mousedown', (e) => {
                // Check if we're clicking on a paintable area (do NOT block painting if view is locked)
                const canvas = sceneEl.renderer.domElement;
                const rect = canvas.getBoundingClientRect();
                this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, sceneEl.camera);
                const intersects = this.raycaster.intersectObject(this.mesh, true);
                if (intersects.length > 0 && intersects[0].uv) {
                    const uv = intersects[0].uv;
                    const x = Math.floor(uv.x * this.canvasResolution);
                    const y = Math.floor((1 - uv.y) * this.canvasResolution);
                    const idx = (y * this.canvasResolution + x) * 4;
                    // If we're on a paintable area, start painting and disable orbit controls
                    if (this.maskData.data[idx] > 200 && this.maskData.data[idx+1] > 200 && this.maskData.data[idx+2] > 200) {
                        this.isPainting = true;
                        this.lastPaintY = e.clientY;
                        this.downstrokeDelta = 0;
                        this.orbitCamera.setAttribute('orbit-controls', 'enableRotate', false);
                        this.showBrushPreview(e.clientX, e.clientY);
                        this.updateCursor(true);
                    }
                }
            });

            window.addEventListener('mouseup', () => {
                if (this.isPainting) {
                    this.isPainting = false;
                    this.lastPaintY = null;
                    this.downstrokeDelta = 0;
                    if (!this.isViewLocked) {
                        this.orbitCamera.setAttribute('orbit-controls', 'enableRotate', true);
                    }
                    // Don't hide preview here; let mousemove handle it
                }
                // On mouseup, update cursor (in case painting stopped)
                this.updateCursor(false);
            });

            // Brush texture for fake normal effect
            this.useTextureBrush = true;
            this.brushTexture = new window.Image();
            this.brushTexture.src = 'brush2.png'; // <-- Place your PNG here
            this.brushPattern = null;
            this.brushTexture.onload = () => {
                this.brushPattern = this.paintLayerCtx.createPattern(this.brushTexture, 'repeat');
            };

            // Add zoom tracking
            this.zoomDisplay = document.getElementById('zoomValue');
            this.initialDistance = 3.5; // Should match initialPosition.z

            // Set default cursor on init
            document.body.style.cursor = 'grab';
        },
        tick: function () {
            // Real-time zoom update
            const camera = document.querySelector('[camera]');
            if (!camera) return;
            const controls = camera.components['orbit-controls'];
            if (!controls || !controls.controls) return;
            const threeControls = controls.controls;
            const currentDistance = threeControls.object.position.distanceTo(threeControls.target);
            // Get min and max distance from orbit-controls attribute
            const orbitAttr = camera.getAttribute('orbit-controls');
            const minDistance = orbitAttr.minDistance || 2.7;
            const maxDistance = orbitAttr.maxDistance || 3.5;
            let zoomPercent = ((maxDistance - currentDistance) / (maxDistance - minDistance)) * 100;
            zoomPercent = Math.max(0, Math.min(100, zoomPercent));
            if (this.zoomDisplay) {
                this.zoomDisplay.textContent = Math.round(zoomPercent) + '%';
            }
        },
        remove: function() {
            // No tick listener to clean up
        },
        applyTexture: function () {
            // Composite: base + paint layer
            this.paintCtx.clearRect(0, 0, this.canvasResolution, this.canvasResolution);
            this.paintCtx.drawImage(this.baseImage, 0, 0, this.canvasResolution, this.canvasResolution);
            this.paintCtx.drawImage(this.paintLayerCanvas, 0, 0, this.canvasResolution, this.canvasResolution);
            this.texture.needsUpdate = true;
            // Set on all mesh materials
            this.mesh.traverse(obj => {
                if (obj.isMesh && obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => {
                            mat.map = this.texture;
                            mat.needsUpdate = true;
                        });
                    } else {
                        obj.material.map = this.texture;
                        obj.material.needsUpdate = true;
                    }
                }
            });
        }, 
        paintFromMouse: function(e) {
            if (!this.mesh || !this.maskData) return;
            const sceneEl = this.el.sceneEl;
            const canvas = sceneEl.renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            this.raycaster.setFromCamera(this.mouse, sceneEl.camera);
            const intersects = this.raycaster.intersectObject(this.mesh, true);
            if (intersects.length > 0 && intersects[0].uv) {
                const uv = intersects[0].uv;
                const x = Math.floor(uv.x * this.canvasResolution);
                const y = Math.floor((1 - uv.y) * this.canvasResolution);
                // Only paint if mask is white here
                const idx = (y * this.canvasResolution + x) * 4;
                if (this.maskData.data[idx] > 200 && this.maskData.data[idx+1] > 200 && this.maskData.data[idx+2] > 200) {
                    this.paintLayerCtx.save();
                    this.paintLayerCtx.beginPath();
                    this.paintLayerCtx.arc(x, y, this.brushSize / 2, 0, 2 * Math.PI);
                    this.paintLayerCtx.closePath();
                    this.paintLayerCtx.clip();
                    if (this.brushPattern) {
                        // Draw the texture
                        this.paintLayerCtx.globalAlpha = 1.0;
                        this.paintLayerCtx.fillStyle = this.brushPattern;
                        this.paintLayerCtx.fillRect(
                            x - this.brushSize / 2,
                            y - this.brushSize / 2,
                            this.brushSize,
                            this.brushSize
                        );
                        // Overlay the color with some transparency
                        this.paintLayerCtx.globalAlpha = 0.5; // Adjust for more/less color tint
                        this.paintLayerCtx.fillStyle = this.brushColor;
                        this.paintLayerCtx.beginPath();
                        this.paintLayerCtx.arc(x, y, this.brushSize / 2, 0, 2 * Math.PI);
                        this.paintLayerCtx.fill();
                        this.paintLayerCtx.globalAlpha = 1.0; // Reset alpha
                    } else {
                        this.paintLayerCtx.fillStyle = this.brushColor;
                        this.paintLayerCtx.beginPath();
                        this.paintLayerCtx.arc(x, y, this.brushSize / 2, 0, 2 * Math.PI);
                        this.paintLayerCtx.fill();
                    }
                    this.paintLayerCtx.restore();
                    this.applyTexture(); // Only update texture on paint
                    this.coverageNeedsUpdate = true; // Batch coverage update
                }
            }
        },
        calculateCoverage: function() {
            if (!this.maskData) return;
            const paintData = this.paintLayerCtx.getImageData(0, 0, this.canvasResolution, this.canvasResolution);
            let paintableCount = 0;
            let paintedCount = 0;
            for (let i = 0; i < this.maskData.data.length; i += 4) {
                if (this.maskData.data[i] > 200 && this.maskData.data[i + 1] > 200 && this.maskData.data[i + 2] > 200) {
                    paintableCount++;
                    if (paintData.data[i + 3] > 0) {
                        paintedCount++;
                    }
                }
            }
            this.paintablePixels = paintableCount;
            this.paintedPixels = paintedCount;
            const coverage = paintableCount > 0 ? (paintedCount / paintableCount * 100).toFixed(1) : '0.0';
            this.coverageDisplay.textContent = `Coverage: ${coverage}%`;
            if (coverage < 25) {
                this.coverageDisplay.style.background = 'rgba(255,0,0,0.7)';
            } else if (coverage < 50) {
                this.coverageDisplay.style.background = 'rgba(255,165,0,0.7)';
            } else if (coverage < 75) {
                this.coverageDisplay.style.background = 'rgba(255,255,0,0.7)';
            } else {
                this.coverageDisplay.style.background = 'rgba(0,255,0,0.7)';
            }
        }
    });

    // UI handler for invalid-paint-direction event
    (function() {
      let warningTimeout = null;
      const warningDiv = document.getElementById('downstrokeWarning');
      window.addEventListener('invalid-paint-direction', function() {
        if (warningTimeout) {
          clearTimeout(warningTimeout);
        }
        warningDiv.style.display = 'block';
        warningTimeout = setTimeout(() => {
          warningDiv.style.display = 'none';
          warningTimeout = null;
        }, 3000);
      });
    })();

      // Wait for both DOM and A-Frame to be ready
      document.addEventListener('DOMContentLoaded', () => {
            const scene = document.querySelector('a-scene');
            if (scene) {
                scene.addEventListener('loaded', () => { 
                    console.log('scene loaded');
                    if (AFRAME.utils.getUrlParameter('debug') === 'true') {
                        var script = document.createElement('script');
                        script.src = './debug.js';
                        document.head.appendChild(script);
                    }

                });
            }
        });
    </script>
</body>
</html>